# -*- coding: utf-8 -*-
"""PruebaDD360_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sktCZFpT_xp5uUwIHat5bWCQrk9AYZSn

# Reto / Instrucciones

Con el archivo listings.csv, construye un m√≥delo en python que nos permita preguntarle cualquier cosa al data set.
- Ejemplo: ¬øCu√°l es el precio promedio de los departamentos en venta?
- Respuesta: El precio promedio de los departamentos en venta es de 2.5 millones


Notas: Aunque se pueden utilizar modelos de lenguaje privados, preferimos soluciones que utilicen modelos de lenguaje open source.
  - Bonus points: Entregar reto montado en una API

---


# **Descripcion de las tareas que voy a realizar**

Para desarrollar un modelo en Python que me permita realizar consultas sobre el dataset proporcionado (en este caso, listings.csv), seguir√© varios pasos. Utilizar√© herramientas de c√≥digo abierto para el an√°lisis y construcci√≥n del modelo. Finalmente, expondr√© el modelo a trav√©s de una API sencilla.

Los pasos que seguir√© son los siguientes:

1. **An√°lisis Preliminar del Dataset**
  - Primero, necesito entender la estructura y el contenido del archivo listings.csv. Para esto, cargar√© el archivo y visualizar√© las primeras filas.

2. **Limpieza y Preparaci√≥n de Datos**
  - Dependiendo de la estructura y calidad de los datos, puede ser necesario realizar limpieza y transformaciones, como tratar valores faltantes, normalizar textos, convertir tipos de datos, etc.

3. **Desarrollo del Modelo para Consultas**
  - Para permitir consultas como el precio promedio, utilizar√© funciones de Pandas para calcular estad√≠sticas descriptivas. No es necesario un modelo de aprendizaje autom√°tico para este tipo de consultas. Usare un chatbot de tipo if/else.

4. **Probar chatbot**

.

A. **Probar un modelo preentrenado (BERT)**

B. **Creaci√≥n de la API** (Si alcanza el tiempo)
  - Utilizar√© Flask, un micro framework de Python, para exponer mi modelo como una API.

---
# **Para probar el chatbot corre el codigo y revisa el funcionamiento en la seccion 4.**

---
- Nota: es necesario importar la data, yo use Google Colab y tenia los documentos en Drive.

---

# 1) **An√°lisis Preliminar del Dataset**
"""

# Mounting Google Drive
from google.colab import drive
drive.mount('/content/drive')

"""## Imports"""

!pip install transformers

pip install transformers torch

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
import sklearn

from transformers import BertTokenizer, BertForQuestionAnswering
import torch

from transformers import AutoModelForQuestionAnswering, AutoTokenizer
from transformers import DistilBertForSequenceClassification, DistilBertTokenizerFast

"""## Data

üõë Modifica el file_path para cargar el archivo
"""

# Cargando la data
file_path = '/content/drive/MyDrive/Colab Notebooks/OtherNotebooks/DD360/listings.csv'
df = pd.read_csv(file_path, na_values='NaN')

# Agregando la columna 'price_sqm' que representa el precio por metro cuadrado
df['price_sqm'] = df['last_price'] / df['surface_total']

# df.head()
df

# Cambiando 'NaN' a 0 en las columnas 'has_pool' y 'has_terrace'
df['has_pool'] = df['has_pool'].fillna(0)
df['has_terrace'] = df['has_terrace'].fillna(0)

# Descriptive statistics for the dataset
descriptive_stats = df.describe()

# Checking for missing values
missing_values = df.isnull().sum()

# Data types
data_types = df.dtypes

# (descriptive_stats, missing_values, data_types)
print("\nEstadisticas Descriptivas: \n \n", descriptive_stats)
print("\n---------------------------------------------------------------------------")
print("\nMissing values: ", missing_values)
print("\n---------------------------------------------------------------------------")
print("\nTipos de datos: ", data_types)

"""## An√°lisis de Datos"""

# Contando el n√∫mero de departamentos en renta y los que est√°n en venta
num_departamentos_renta = df[df['listing_type'] == 'for-rent']['property_type'].eq('apartment').sum()
num_departamentos_venta = df[df['listing_type'] == 'for-sale']['property_type'].eq('apartment').sum()

# Contando el n√∫mero de casas en renta y los que est√°n en venta
num_casas_renta = df[df['listing_type'] == 'for-rent']['property_type'].eq('house').sum()
num_casas_venta = df[df['listing_type'] == 'for-sale']['property_type'].eq('house').sum()

# Contando el n√∫mero de casas en el dataset
num_casas = df['property_type'].eq('house').sum()
num_depas = df['property_type'].eq('apartment').sum()

print("Casas: ", num_casas)
print("Venta: ", num_casas_venta)
print("Renta: ", num_casas_renta)

print("\nDepartamentos: ", num_depas)
print("Venta: ", num_departamentos_venta)
print("Renta: ", num_departamentos_renta)


# N√∫mero de propiedades en renta y en venta
total_renta = df[df['listing_type'] == 'for-rent'].shape[0]
total_venta = df[df['listing_type'] == 'for-sale'].shape[0]

# N√∫mero de propiedades con alberca
total_con_alberca = df[df['has_pool'] > 0].shape[0]

# N√∫mero de propiedades con terraza
total_con_terraza = df[df['has_terrace'] > 0].shape[0]

# Gr√°fica para visualizar la cantidad de departamentos y casas seg√∫n est√©n a la renta o a la venta
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='property_type', hue='listing_type')
plt.title('Cantidad de Departamentos y Casas en Renta y Venta')
plt.xlabel('Tipo de Propiedad')
plt.ylabel('Cantidad')
plt.show()

sns.set(style="whitegrid")
fig, axes = plt.subplots(3, 2, figsize=(15, 15))

# Gr√°fica 1: Distribuci√≥n de propiedades por tipo (Casa o Departamento)
sns.countplot(data=df, x='property_type', ax=axes[0, 0])
axes[0, 0].set_title('Distribuci√≥n de Propiedades por Tipo')

# Gr√°fica 2: Distribuci√≥n de propiedades por tipo de listado (Venta o Renta)
sns.countplot(data=df, x='listing_type', ax=axes[0, 1])
axes[0, 1].set_title('Distribuci√≥n de Propiedades por Tipo de Listado')

# Gr√°fica 3: Precio de las propiedades en venta
sns.histplot(df[df['listing_type'] == 'for-sale']['last_price'], kde=True, ax=axes[1, 0])
axes[1, 0].set_title('Distribuci√≥n de Precios de Propiedades en Venta')
axes[1, 0].set(xlabel='Precio', ylabel='Frecuencia')

# Gr√°fica 4: Distribuci√≥n del n√∫mero de habitaciones en departamentos
sns.histplot(df[df['property_type'] == 'apartment']['num_bedrooms'], bins=range(1, 10), kde=False, ax=axes[1, 1])
axes[1, 1].set_title('Distribuci√≥n del N√∫mero de Habitaciones en Departamentos')
axes[1, 1].set(xlabel='N√∫mero de Habitaciones', ylabel='Frecuencia')

# Gr√°fica 5: Relaci√≥n entre el n√∫mero de habitaciones y el precio de venta
sns.scatterplot(data=df[df['listing_type'] == 'for-sale'], x='num_bedrooms', y='last_price', ax=axes[2, 0])
axes[2, 0].set_title('Relaci√≥n entre N√∫mero de Habitaciones y Precio de Venta')
axes[2, 0].set(xlabel='N√∫mero de Habitaciones', ylabel='Precio de Venta')

# Gr√°fica 6: Relaci√≥n entre la superficie total y el precio de venta
sns.scatterplot(data=df[df['listing_type'] == 'for-sale'], x='surface_total', y='last_price', ax=axes[2, 1])
axes[2, 1].set_title('Relaci√≥n entre Superficie Total y Precio de Venta')
axes[2, 1].set(xlabel='Superficie Total (m¬≤)', ylabel='Precio de Venta')

plt.tight_layout()
plt.show()

"""---



# **2) Limpieza y Preparaci√≥n de Datos**

## Preprocessing
"""

# var_drop = ['property_id'] # Suponemos que property_id no es relevante para este caso
# df.drop(var_drop, axis=1, inplace=True)

# Verificando los cambios
df.head()

missing_values = df.isnull().sum()
data_types = df.dtypes

print("\nMissing values: ", missing_values)
print("\nTipos de datos: ", data_types)

# Dropping missing values
df = df.dropna()

# One-Hot encoding para las columnas listing_type y property_type

cat_var = ['listing_type', 'property_type']

# One-hot encoding training
encoded_columns = pd.get_dummies(df[cat_var], drop_first=False)
# Adding the one-hot encoded columns to the original DataFrame
enco_df = pd.concat([df, encoded_columns], axis=1)
# Drop the original columns that were one-hot encoded
enco_df.drop(cat_var, axis=1, inplace=True)

enco_df



"""# 3) Modelo"""

#  modelo multiling√ºe BERT
model_name = 'bert-base-multilingual-cased'

tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForQuestionAnswering.from_pretrained(model_name)

"""## Reglas y consultas"""

# Interpreta la pregunta y decide el tipo de consulta realizar
def consulta_dataset(pregunta):
    pregunta = pregunta.lower()  # Convertir la pregunta a min√∫sculas para la comparaci√≥n
    nu_casas = df['property_type'].eq('house').sum()
    nu_depas = df['property_type'].eq('apartment').sum()

    # Numero de habitaciones por casa
    num_casas_1_habitacion = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 1)].shape[0]
    num_casas_2_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 2)].shape[0]
    num_casas_3_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 3)].shape[0]
    num_casas_4_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 4)].shape[0]
    num_casas_5_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 5)].shape[0]

    # Numero de habitaciones por departamento
    num_deptos_1_habitacion = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 1)].shape[0]
    num_deptos_2_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 2)].shape[0]
    num_deptos_3_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 3)].shape[0]
    num_deptos_4_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 4)].shape[0]
    num_deptos_5_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 5)].shape[0]

    # Calculando el promedio de habitaciones para casas y departamentos en renta y venta
    promedio_habitaciones_casas_venta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-sale')]['num_bedrooms'].mean()
    promedio_habitaciones_casas_renta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-rent')]['num_bedrooms'].mean()
    promedio_habitaciones_deptos_venta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-sale')]['num_bedrooms'].mean()
    promedio_habitaciones_deptos_renta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-rent')]['num_bedrooms'].mean()

    # Calculando el precio promedio de una casa y de un departamento
    precio_promedio_casa = df[df['property_type'] == 'house']['last_price'].mean()
    precio_promedio_departamento = df[df['property_type'] == 'apartment']['last_price'].mean()

    # Calculando el precio promedio de casas y departamentos, tanto en venta como en renta
    precio_promedio_casas_venta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-sale')]['last_price'].mean()
    precio_promedio_casas_renta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-rent')]['last_price'].mean()
    precio_promedio_deptos_venta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-sale')]['last_price'].mean()
    precio_promedio_deptos_renta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-rent')]['last_price'].mean()

    # Promedio de ba√±os para casas y departamentos
    promedio_banos_casa = df[df['property_type'] == 'house']['num_bathrooms'].mean()
    promedio_banos_departamento = df[df['property_type'] == 'apartment']['num_bathrooms'].mean()

    # propiedades
    if 'cu√°ntas propiedades est√°n listadas' in pregunta or 'cuantas propiedades hay'in pregunta:
        total_listadas = df.shape[0]
        return f"Hay {total_listadas} propiedades listadas. De las cuales hay {nu_casas} casas y {nu_depas} departamentos."


#####
    # Casas
    elif 'cu√°ntas casas estan listadas' in pregunta or 'cuantas casas hay'in pregunta:
        casas_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'house')].shape[0]
        casas_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'house')].shape[0]
        return f"Hay {nu_casas} casas. De las cuales hay {casas_venta} en venta y {casas_renta} en renta."
    elif 'casas estan en venta' in pregunta:
        casas_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {casas_venta} casas en venta."
    elif 'casas estan en renta' in pregunta:
        casas_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {casas_renta} casas en renta."

    elif 'promedio de habitaciones en las casas en venta' in pregunta:
        return f"El promedio de habitaciones en las casas en venta es de {promedio_habitaciones_casas_venta:.2f}."
    elif 'promedio de habitaciones en las casas  en renta' in pregunta:
        return f"El promedio de habitaciones en las casas  en renta es de {promedio_habitaciones_casas_renta:.2f}."

    elif 'casas con 1 habitacion' in pregunta or 'casas tienen 1 habitacion' in pregunta:
        return f"Hay {num_casas_1_habitacion:.2f} casas con 1 habitacion."
    elif 'casas con 2 habitaciones' in pregunta or 'casas tienen 2 habitaciones' in pregunta:
        return f"Hay {num_casas_2_habitaciones:.2f} casas con 2 habitaciones."
    elif 'casas con 3 habitaciones' in pregunta or 'casas tienen 3 habitaciones' in pregunta:
        return f"Hay {num_casas_3_habitaciones:.2f} casas con 3 habitaciones."
    elif 'casas con 4 habitaciones' in pregunta or 'casas tienen 4 habitaciones' in pregunta:
        return f"Hay {num_casas_4_habitaciones:.2f} casas con 4 habitaciones."
    elif 'casas con 5 habitaciones' in pregunta or 'casas tienen 5 habitaciones' in pregunta:
        return f"Hay {num_casas_5_habitaciones:.2f} casas con 5 habitaciones."


    elif 'precio promedio de una casa en renta'in pregunta:
        return f"El precio promedio de una casa en renta es de {precio_promedio_casas_renta:.2f}."
    elif 'precio promedio de una casa en venta'in pregunta:
        return f"El precio promedio de una casa en venta es de {precio_promedio_casas_venta:.2f}."

    elif 'precio promedio de una casa' in pregunta:
        return f"El precio promedio de una casa es {precio_promedio_casa:.2f}."

#####
    # Departamentos
    elif 'cu√°ntos departamentos estan listadas' in pregunta or 'cuantos departamentos hay'in pregunta:
        # nu_depas = df['property_type'].eq('apartment').sum()
        deptos_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'apartment')].shape[0]
        deptos_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {nu_depas} departamentos. De los cuales hay {deptos_venta} en venta y {deptos_renta} en renta."
    elif 'departamentos estan en venta' in pregunta:
        deptos_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {deptos_venta} departamentos en venta."
    elif 'departamentos estan en renta' in pregunta:
        deptos_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {deptos_renta} departamentos en renta."

    elif 'promedio de habitaciones en los departamentos en venta' in pregunta:
        promedio_habitaciones_depa_venta = df[df['listing_type'] == 'for-sale']['num_bedrooms'].mean()
        return f"El promedio de habitaciones en departamentos en venta es de {promedio_habitaciones_deptos_venta:.2f}."
    elif 'promedio de habitaciones en los departamentos en renta' in pregunta:
        promedio_habitaciones_depa_renta = df[df['listing_type'] == 'for-rent']['num_bedrooms'].mean()
        return f"El promedio de habitaciones en departamentos en renta es de {promedio_habitaciones_deptos_renta:.2f}."
    elif 'precio promedio de un departamento' in pregunta:
        precio_promedio = df['last_price'].mean()
        return f"El precio promedio de un departamento {precio_promedio_departamento:.2f}"

    elif 'departamentos con 1 habitacion' in pregunta or 'departamentos tienen 1 habitacion' in pregunta:
        return f"Hay {num_deptos_1_habitacion:.2f} departamentos con 1 habitacion."
    elif 'departamentos con 2 habitaciones' in pregunta or 'departamentos tienen 2 habitaciones' in pregunta:
        return f"Hay {num_deptos_2_habitaciones:.2f} departamentos con 2 habitaciones."
    elif 'departamentos con 3 habitaciones' in pregunta or 'departamentos tienen 3 habitaciones' in pregunta:
        return f"Hay {num_deptos_3_habitaciones:.2f} departamentos con 3 habitaciones."
    elif 'departamentos con 4 habitaciones' in pregunta or 'departamentos tienen 4 habitaciones' in pregunta:
        return f"Hay {num_deptos_4_habitaciones:.2f} departamentos con 4 habitaciones."
    elif 'departamentos con 5 habitaciones' in pregunta or 'departamentos tienen 5 habitaciones' in pregunta:
        return f"Hay {num_deptos_5_habitaciones:.2f} departamentos con 5 habitaciones."

    elif 'precio promedio de un departamento en renta'in pregunta:
        return f"El precio promedio de un departamento en renta es de {precio_promedio_departamento_renta:.2f}."
    elif 'precio promedio de un departamento en venta'in pregunta:
        return f"El precio promedio de un departamento en venta es de {precio_promedio_departamento_venta:.2f}."

    elif 'precio promedio de un departamento' in pregunta:
        return f"El precio promedio de un departamento es {precio_promedio_departamento:.2f}."


    # alberca
    elif 'propiedades tienen piscina' in pregunta or 'propiedades tienen alberca' in pregunta:
        cantidad_con_piscina = df[df['has_pool'] == 1].shape[0]
        casas_con_alberca = df[(df['property_type'] == 'house') & (df['has_pool'] == 1)].shape[0]
        departamentos_con_alberca = df[(df['property_type'] == 'apartment') & (df['has_pool'] == 1)].shape[0]
        return f"Hay {cantidad_con_piscina} propiedades con alberca. Las cuales estan en {casas_con_alberca} casas y {departamentos_con_alberca} departamentos."
    elif 'properties have a pool' in pregunta:
        cantidad_con_piscina = df[df['has_pool'] == 1].shape[0]
        return f"There are {cantidad_con_piscina} properties with a pool."


    # terraza
    elif 'propiedades tienen terraza' in pregunta or 'terrazas hay' in pregunta:
        con_terraza = df[df['has_terrace'] == 1].shape[0]
        casas_con_terraza = df[(df['property_type'] == 'house') & (df['has_terrace'] == 1)].shape[0]
        departamentos_con_terraza = df[(df['property_type'] == 'apartment') & (df['has_terrace'] == 1)].shape[0]
        return f"Hay {con_terraza} propiedades con terraza. Las cuales estan en {casas_con_terraza} casas y {departamentos_con_terraza} departamentos."
    elif 'properties have a terrace' in pregunta:
        con_terraza = df[df['has_terrace'] == 1].shape[0]
        return f"Their are {con_terraza} properties with a terrace."

    # rango precio
    elif 'rango de precios' in pregunta:
        precio_min = df['last_price'].min()
        precio_max = df['last_price'].max()
        return f"Los precios de las propiedades van desde {precio_min} hasta {precio_max}."
    elif 'range of prices' in pregunta:
        precio_min = df['last_price'].min()
        precio_max = df['last_price'].max()
        return f"The property price range from {precio_min} to {precio_max}."

    elif 'superficie promedio de los departamentos' in pregunta:
        superficie_promedio = df[df['property_type'] == 'apartment']['surface_total'].mean()
        return f"La superficie promedio de los departamentos es de {superficie_promedio:.2f} metros cuadrados."
    elif 'superficie promedio de las casas' in pregunta:
        superficie_promedio = df[df['property_type'] == 'house']['surface_total'].mean()
        return f"La superficie promedio de los departamentos es de {superficie_promedio:.2f} metros cuadrados."

    # # Ba√±os
    elif 'promedio de ba√±os que hay en una casa' in pregunta:
        return f"En una casa hay un promedio de {promedio_banos_casa} ba√±os."
    elif 'promedio de ba√±os que hay en un departamento' in pregunta:
        return f"En un departamento hay un promedio de {promedio_banos_departamento} ba√±os."
    # elif 'XYZ' in pregunta:
    #     return f"Prueba."

    else:
        return "Lo siento, no puedo responder a esa pregunta. Por favor intenta formularla de otra manera"

"""## Implementacion del chatbot"""

def formatear_pregunta(pregunta):
    # Tokeniza la pregunta para el modelo
    inputs = tokenizer(pregunta, return_tensors='pt')
    return inputs

def chatbot(pregunta):
    # Preprocesar la pregunta
    inputs = formatear_pregunta(pregunta)

    # Procesar la pregunta con el modelo
    output = model(**inputs)
    # La respuesta del modelo se utiliza para entender mejor la intenci√≥n de la pregunta.

    # Consulta al dataset (utilizando una funci√≥n simplificada aqu√≠)
    respuesta = consulta_dataset(pregunta)

    return respuesta

"""# 4) **Probar el chatbot**

***Para probar el chatbot puedes escribir tu pregunta en la celada de abajo o crear una lista de preguntas como se ve 2 celdas abajo.***
"""

# Escribe tu pregunta dentro de las comillas
pregunta = "cual es el precio promedio de una casa en renta?"

# No modificar abajo
respuesta = chatbot(pregunta)

print(f"Pregunta: {pregunta}")
print(f"Respuesta: {respuesta}\n")

# Ejemplo de preguntas
preguntas_para_probar = [
    "¬øCu√°l es el precio promedio de los departamentos?",
    "¬øCu√°ntas propiedades tienen piscina?",
    "¬øCu√°ntas propiedades tienen terraza?",
    "¬øCu√°l es el rango de precios de las propiedades?",
    "Cuantas casas hay?",
    "Cuantos departamentos hay?"
]

# No modificar abajo

# Probar el chatbot con cada pregunta
for pregunta in preguntas_para_probar:
    respuesta = chatbot(pregunta)
    print(f"Pregunta: {pregunta}")
    print(f"Respuesta: {respuesta}\n")

"""---



# A) Prueba usando BERT

Dado a que usando if/else no es la manera mas efficiente de hacer un chatbot quer√≠a probar usando un modelo preentrenado y darle el contexto de los datos.
"""

# Cargando el tokenizador y el modelo BERT
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForQuestionAnswering.from_pretrained('bert-base-uncased')

# Verificando si est√° disponible una GPU y moviendo el modelo a GPU si es posible
if torch.cuda.is_available():
    model = model.cuda()

"""## Contexto"""

# Creando contextos para todas las filas del DataFrame
contextos_completos = []

for _, row in df.iterrows():
    context = f"La propiedad con ID {row['id']} es un {row['property_type']} listado como {row['listing_type']}. \
Tiene un precio de {row['last_price']} y una superficie total de {row['surface_total']} metros cuadrados. \
El precio por metro cuadrado es de {row['price_sqm']}. Tiene {row['num_bedrooms']} habitaciones y {row['num_bathrooms']} ba√±os."
    contextos_completos.append(context)

# Mostrando el n√∫mero total de contextos creados
# len(contextos_completos)

contexto_general = f"En este dataset, hay un total de {num_casas} casas y {num_depas} departamentos. \
De estas propiedades, {total_renta} est√°n listadas para renta y {total_venta} est√°n listadas para venta. \
Adem√°s, {total_con_alberca} propiedades cuentan con alberca y {total_con_terraza} tienen terraza."

"""## Funcion para preguntas"""

def answer_question(question, context):
    # Tokenizar la pregunta y el contexto, este paso es necesario para que BERT pueda procesarlos
    inputs = tokenizer.encode_plus(question, context, add_special_tokens=True, return_tensors="pt")

    # Mover los tensores a GPU si est√° disponible
    if torch.cuda.is_available():
        inputs = {k: v.cuda() for k, v in inputs.items()}

    # Obtener la respuesta del modelo
    answer_start_scores, answer_end_scores = model(**inputs, return_dict=False)

    # Encontrar los tokens de inicio y fin de la respuesta
    answer_start = torch.argmax(answer_start_scores)
    answer_end = torch.argmax(answer_end_scores) + 1

    # Convertir los tokens de respuesta a texto
    answer = tokenizer.convert_tokens_to_string(tokenizer.convert_ids_to_tokens(inputs["input_ids"][0][answer_start:answer_end]))

    return answer

"""Probar funcion"""

# Ejemplo de pregunta y contexto
pregunta = "¬øCu√°ntas habitaciones tiene la propiedad?"
contexto = contextos_completos[5]

# Obtener la respuesta de BERT
respuesta = answer_question(pregunta, contexto)
print(respuesta)

pregunta = "¬øCuantas casas hay?"
# contexto = contextos_completos
respuesta = answer_question(pregunta, contexto_general)
respuesta

"""Por alguna razon no he logrado que me regrese una respuesta, esto puede deberse a un par de cosas:

- Longitud del Contexto: BERT tiene un l√≠mite en la cantidad de tokens que puede procesar en una sola entrada (generalmente alrededor de 512 tokens).

- Formulaci√≥n de la Pregunta o del Contexto: BERT puede no entender la pregunta o puede que el contexto que le di no contenga la informaci√≥n necesaria de una forma clara.

- Limitaciones del Modelo: Aunque BERT es muy potente, tiene sus limitaciones. No siempre puede inferir respuestas si la pregunta requiere un entendimiento profundo del contexto o si se necesita realizar un c√°lculo num√©rico basado en datos.

- Problemas T√©cnicos: Podr√≠a haber un problema con la forma en que se est√° ejecutando el modelo o procesando la entrada. Aseg√∫rate de que no hay errores en el c√≥digo y que las entradas se est√°n pasando correctamente al modelo.

---



---



# Exportar Notebook
"""

!pip install nbconvert

!jupyter nbconvert --to html PruebaDD360_1.ipynb


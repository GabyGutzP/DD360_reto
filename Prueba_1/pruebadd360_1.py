# -*- coding: utf-8 -*-
"""PruebaDD360_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sktCZFpT_xp5uUwIHat5bWCQrk9AYZSn

# Reto / Instrucciones

Con el archivo listings.csv, construye un m칩delo en python que nos permita preguntarle cualquier cosa al data set.
- Ejemplo: 쮺u치l es el precio promedio de los departamentos en venta?
- Respuesta: El precio promedio de los departamentos en venta es de 2.5 millones


Notas: Aunque se pueden utilizar modelos de lenguaje privados, preferimos soluciones que utilicen modelos de lenguaje open source.
  - Bonus points: Entregar reto montado en una API

---


# **Descripcion de las tareas que voy a realizar**

Para desarrollar un modelo en Python que me permita realizar consultas sobre el dataset proporcionado (en este caso, listings.csv), seguir칠 varios pasos. Utilizar칠 herramientas de c칩digo abierto para el an치lisis y construcci칩n del modelo. Finalmente, expondr칠 el modelo a trav칠s de una API sencilla.

Los pasos que seguir칠 son los siguientes:

1. **An치lisis Preliminar del Dataset**
  - Primero, necesito entender la estructura y el contenido del archivo listings.csv. Para esto, cargar칠 el archivo y visualizar칠 las primeras filas.

2. **Limpieza y Preparaci칩n de Datos**
  - Dependiendo de la estructura y calidad de los datos, puede ser necesario realizar limpieza y transformaciones, como tratar valores faltantes, normalizar textos, convertir tipos de datos, etc.

3. **Desarrollo del Modelo para Consultas**
  - Para permitir consultas como el precio promedio, utilizar칠 funciones de Pandas para calcular estad칤sticas descriptivas. No es necesario un modelo de aprendizaje autom치tico para este tipo de consultas. Usare un chatbot de tipo if/else.

4. **Probar chatbot**

.

A. **Probar un modelo preentrenado (BERT)**

B. **Creaci칩n de la API** (Si alcanza el tiempo)
  - Utilizar칠 Flask, un micro framework de Python, para exponer mi modelo como una API.

---
# **Para probar el chatbot corre el codigo y revisa el funcionamiento en la seccion 4.**

---
- Nota: es necesario importar la data, yo use Google Colab y tenia los documentos en Drive.

---

# 1) **An치lisis Preliminar del Dataset**
"""

# Mounting Google Drive
from google.colab import drive
drive.mount('/content/drive')

"""## Imports"""

!pip install transformers

pip install transformers torch

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
import sklearn

from transformers import BertTokenizer, BertForQuestionAnswering
import torch

from transformers import AutoModelForQuestionAnswering, AutoTokenizer
from transformers import DistilBertForSequenceClassification, DistilBertTokenizerFast

"""## Data

游띔 Modifica el file_path para cargar el archivo
"""

# Cargando la data
file_path = '/content/drive/MyDrive/Colab Notebooks/OtherNotebooks/DD360/listings.csv'
df = pd.read_csv(file_path, na_values='NaN')

# Agregando la columna 'price_sqm' que representa el precio por metro cuadrado
df['price_sqm'] = df['last_price'] / df['surface_total']

# df.head()
df

# Cambiando 'NaN' a 0 en las columnas 'has_pool' y 'has_terrace'
df['has_pool'] = df['has_pool'].fillna(0)
df['has_terrace'] = df['has_terrace'].fillna(0)

# Descriptive statistics for the dataset
descriptive_stats = df.describe()

# Checking for missing values
missing_values = df.isnull().sum()

# Data types
data_types = df.dtypes

# (descriptive_stats, missing_values, data_types)
print("\nEstadisticas Descriptivas: \n \n", descriptive_stats)
print("\n---------------------------------------------------------------------------")
print("\nMissing values: ", missing_values)
print("\n---------------------------------------------------------------------------")
print("\nTipos de datos: ", data_types)

"""## An치lisis de Datos"""

# Contando el n칰mero de departamentos en renta y los que est치n en venta
num_departamentos_renta = df[df['listing_type'] == 'for-rent']['property_type'].eq('apartment').sum()
num_departamentos_venta = df[df['listing_type'] == 'for-sale']['property_type'].eq('apartment').sum()

# Contando el n칰mero de casas en renta y los que est치n en venta
num_casas_renta = df[df['listing_type'] == 'for-rent']['property_type'].eq('house').sum()
num_casas_venta = df[df['listing_type'] == 'for-sale']['property_type'].eq('house').sum()

# Contando el n칰mero de casas en el dataset
num_casas = df['property_type'].eq('house').sum()
num_depas = df['property_type'].eq('apartment').sum()

print("Casas: ", num_casas)
print("Venta: ", num_casas_venta)
print("Renta: ", num_casas_renta)

print("\nDepartamentos: ", num_depas)
print("Venta: ", num_departamentos_venta)
print("Renta: ", num_departamentos_renta)


# N칰mero de propiedades en renta y en venta
total_renta = df[df['listing_type'] == 'for-rent'].shape[0]
total_venta = df[df['listing_type'] == 'for-sale'].shape[0]

# N칰mero de propiedades con alberca
total_con_alberca = df[df['has_pool'] > 0].shape[0]

# N칰mero de propiedades con terraza
total_con_terraza = df[df['has_terrace'] > 0].shape[0]

# Gr치fica para visualizar la cantidad de departamentos y casas seg칰n est칠n a la renta o a la venta
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='property_type', hue='listing_type')
plt.title('Cantidad de Departamentos y Casas en Renta y Venta')
plt.xlabel('Tipo de Propiedad')
plt.ylabel('Cantidad')
plt.show()

sns.set(style="whitegrid")
fig, axes = plt.subplots(3, 2, figsize=(15, 15))

# Gr치fica 1: Distribuci칩n de propiedades por tipo (Casa o Departamento)
sns.countplot(data=df, x='property_type', ax=axes[0, 0])
axes[0, 0].set_title('Distribuci칩n de Propiedades por Tipo')

# Gr치fica 2: Distribuci칩n de propiedades por tipo de listado (Venta o Renta)
sns.countplot(data=df, x='listing_type', ax=axes[0, 1])
axes[0, 1].set_title('Distribuci칩n de Propiedades por Tipo de Listado')

# Gr치fica 3: Precio de las propiedades en venta
sns.histplot(df[df['listing_type'] == 'for-sale']['last_price'], kde=True, ax=axes[1, 0])
axes[1, 0].set_title('Distribuci칩n de Precios de Propiedades en Venta')
axes[1, 0].set(xlabel='Precio', ylabel='Frecuencia')

# Gr치fica 4: Distribuci칩n del n칰mero de habitaciones en departamentos
sns.histplot(df[df['property_type'] == 'apartment']['num_bedrooms'], bins=range(1, 10), kde=False, ax=axes[1, 1])
axes[1, 1].set_title('Distribuci칩n del N칰mero de Habitaciones en Departamentos')
axes[1, 1].set(xlabel='N칰mero de Habitaciones', ylabel='Frecuencia')

# Gr치fica 5: Relaci칩n entre el n칰mero de habitaciones y el precio de venta
sns.scatterplot(data=df[df['listing_type'] == 'for-sale'], x='num_bedrooms', y='last_price', ax=axes[2, 0])
axes[2, 0].set_title('Relaci칩n entre N칰mero de Habitaciones y Precio de Venta')
axes[2, 0].set(xlabel='N칰mero de Habitaciones', ylabel='Precio de Venta')

# Gr치fica 6: Relaci칩n entre la superficie total y el precio de venta
sns.scatterplot(data=df[df['listing_type'] == 'for-sale'], x='surface_total', y='last_price', ax=axes[2, 1])
axes[2, 1].set_title('Relaci칩n entre Superficie Total y Precio de Venta')
axes[2, 1].set(xlabel='Superficie Total (m)', ylabel='Precio de Venta')

plt.tight_layout()
plt.show()

"""---



# **2) Limpieza y Preparaci칩n de Datos**

## Preprocessing
"""

# var_drop = ['property_id'] # Suponemos que property_id no es relevante para este caso
# df.drop(var_drop, axis=1, inplace=True)

# Verificando los cambios
df.head()

missing_values = df.isnull().sum()
data_types = df.dtypes

print("\nMissing values: ", missing_values)
print("\nTipos de datos: ", data_types)

# Dropping missing values
df = df.dropna()

# One-Hot encoding para las columnas listing_type y property_type

cat_var = ['listing_type', 'property_type']

# One-hot encoding training
encoded_columns = pd.get_dummies(df[cat_var], drop_first=False)
# Adding the one-hot encoded columns to the original DataFrame
enco_df = pd.concat([df, encoded_columns], axis=1)
# Drop the original columns that were one-hot encoded
enco_df.drop(cat_var, axis=1, inplace=True)

enco_df



"""# 3) Modelo"""

#  modelo multiling칲e BERT
model_name = 'bert-base-multilingual-cased'

tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForQuestionAnswering.from_pretrained(model_name)

"""## Reglas y consultas"""

# Interpreta la pregunta y decide el tipo de consulta realizar
def consulta_dataset(pregunta):
    pregunta = pregunta.lower()  # Convertir la pregunta a min칰sculas para la comparaci칩n
    nu_casas = df['property_type'].eq('house').sum()
    nu_depas = df['property_type'].eq('apartment').sum()

    # Numero de habitaciones por casa
    num_casas_1_habitacion = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 1)].shape[0]
    num_casas_2_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 2)].shape[0]
    num_casas_3_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 3)].shape[0]
    num_casas_4_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 4)].shape[0]
    num_casas_5_habitaciones = df[(df['property_type'] == 'house') & (df['num_bedrooms'] == 5)].shape[0]

    # Numero de habitaciones por departamento
    num_deptos_1_habitacion = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 1)].shape[0]
    num_deptos_2_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 2)].shape[0]
    num_deptos_3_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 3)].shape[0]
    num_deptos_4_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 4)].shape[0]
    num_deptos_5_habitaciones = df[(df['property_type'] == 'apartment') & (df['num_bedrooms'] == 5)].shape[0]

    # Calculando el promedio de habitaciones para casas y departamentos en renta y venta
    promedio_habitaciones_casas_venta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-sale')]['num_bedrooms'].mean()
    promedio_habitaciones_casas_renta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-rent')]['num_bedrooms'].mean()
    promedio_habitaciones_deptos_venta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-sale')]['num_bedrooms'].mean()
    promedio_habitaciones_deptos_renta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-rent')]['num_bedrooms'].mean()

    # Calculando el precio promedio de una casa y de un departamento
    precio_promedio_casa = df[df['property_type'] == 'house']['last_price'].mean()
    precio_promedio_departamento = df[df['property_type'] == 'apartment']['last_price'].mean()

    # Calculando el precio promedio de casas y departamentos, tanto en venta como en renta
    precio_promedio_casas_venta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-sale')]['last_price'].mean()
    precio_promedio_casas_renta = df[(df['property_type'] == 'house') & (df['listing_type'] == 'for-rent')]['last_price'].mean()
    precio_promedio_deptos_venta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-sale')]['last_price'].mean()
    precio_promedio_deptos_renta = df[(df['property_type'] == 'apartment') & (df['listing_type'] == 'for-rent')]['last_price'].mean()

    # Promedio de ba침os para casas y departamentos
    promedio_banos_casa = df[df['property_type'] == 'house']['num_bathrooms'].mean()
    promedio_banos_departamento = df[df['property_type'] == 'apartment']['num_bathrooms'].mean()

    # propiedades
    if 'cu치ntas propiedades est치n listadas' in pregunta or 'cuantas propiedades hay'in pregunta:
        total_listadas = df.shape[0]
        return f"Hay {total_listadas} propiedades listadas. De las cuales hay {nu_casas} casas y {nu_depas} departamentos."


#####
    # Casas
    elif 'cu치ntas casas estan listadas' in pregunta or 'cuantas casas hay'in pregunta:
        casas_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'house')].shape[0]
        casas_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'house')].shape[0]
        return f"Hay {nu_casas} casas. De las cuales hay {casas_venta} en venta y {casas_renta} en renta."
    elif 'casas estan en venta' in pregunta:
        casas_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {casas_venta} casas en venta."
    elif 'casas estan en renta' in pregunta:
        casas_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {casas_renta} casas en renta."

    elif 'promedio de habitaciones en las casas en venta' in pregunta:
        return f"El promedio de habitaciones en las casas en venta es de {promedio_habitaciones_casas_venta:.2f}."
    elif 'promedio de habitaciones en las casas  en renta' in pregunta:
        return f"El promedio de habitaciones en las casas  en renta es de {promedio_habitaciones_casas_renta:.2f}."

    elif 'casas con 1 habitacion' in pregunta or 'casas tienen 1 habitacion' in pregunta:
        return f"Hay {num_casas_1_habitacion:.2f} casas con 1 habitacion."
    elif 'casas con 2 habitaciones' in pregunta or 'casas tienen 2 habitaciones' in pregunta:
        return f"Hay {num_casas_2_habitaciones:.2f} casas con 2 habitaciones."
    elif 'casas con 3 habitaciones' in pregunta or 'casas tienen 3 habitaciones' in pregunta:
        return f"Hay {num_casas_3_habitaciones:.2f} casas con 3 habitaciones."
    elif 'casas con 4 habitaciones' in pregunta or 'casas tienen 4 habitaciones' in pregunta:
        return f"Hay {num_casas_4_habitaciones:.2f} casas con 4 habitaciones."
    elif 'casas con 5 habitaciones' in pregunta or 'casas tienen 5 habitaciones' in pregunta:
        return f"Hay {num_casas_5_habitaciones:.2f} casas con 5 habitaciones."


    elif 'precio promedio de una casa en renta'in pregunta:
        return f"El precio promedio de una casa en renta es de {precio_promedio_casas_renta:.2f}."
    elif 'precio promedio de una casa en venta'in pregunta:
        return f"El precio promedio de una casa en venta es de {precio_promedio_casas_venta:.2f}."

    elif 'precio promedio de una casa' in pregunta:
        return f"El precio promedio de una casa es {precio_promedio_casa:.2f}."

#####
    # Departamentos
    elif 'cu치ntos departamentos estan listadas' in pregunta or 'cuantos departamentos hay'in pregunta:
        # nu_depas = df['property_type'].eq('apartment').sum()
        deptos_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'apartment')].shape[0]
        deptos_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {nu_depas} departamentos. De los cuales hay {deptos_venta} en venta y {deptos_renta} en renta."
    elif 'departamentos estan en venta' in pregunta:
        deptos_venta = df[(df['listing_type'] == 'for-sale') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {deptos_venta} departamentos en venta."
    elif 'departamentos estan en renta' in pregunta:
        deptos_renta = df[(df['listing_type'] == 'for-rent') & (df['property_type'] == 'apartment')].shape[0]
        return f"Hay {deptos_renta} departamentos en renta."

    elif 'promedio de habitaciones en los departamentos en venta' in pregunta:
        promedio_habitaciones_depa_venta = df[df['listing_type'] == 'for-sale']['num_bedrooms'].mean()
        return f"El promedio de habitaciones en departamentos en venta es de {promedio_habitaciones_deptos_venta:.2f}."
    elif 'promedio de habitaciones en los departamentos en renta' in pregunta:
        promedio_habitaciones_depa_renta = df[df['listing_type'] == 'for-rent']['num_bedrooms'].mean()
        return f"El promedio de habitaciones en departamentos en renta es de {promedio_habitaciones_deptos_renta:.2f}."
    elif 'precio promedio de un departamento' in pregunta:
        precio_promedio = df['last_price'].mean()
        return f"El precio promedio de un departamento {precio_promedio_departamento:.2f}"

    elif 'departamentos con 1 habitacion' in pregunta or 'departamentos tienen 1 habitacion' in pregunta:
        return f"Hay {num_deptos_1_habitacion:.2f} departamentos con 1 habitacion."
    elif 'departamentos con 2 habitaciones' in pregunta or 'departamentos tienen 2 habitaciones' in pregunta:
        return f"Hay {num_deptos_2_habitaciones:.2f} departamentos con 2 habitaciones."
    elif 'departamentos con 3 habitaciones' in pregunta or 'departamentos tienen 3 habitaciones' in pregunta:
        return f"Hay {num_deptos_3_habitaciones:.2f} departamentos con 3 habitaciones."
    elif 'departamentos con 4 habitaciones' in pregunta or 'departamentos tienen 4 habitaciones' in pregunta:
        return f"Hay {num_deptos_4_habitaciones:.2f} departamentos con 4 habitaciones."
    elif 'departamentos con 5 habitaciones' in pregunta or 'departamentos tienen 5 habitaciones' in pregunta:
        return f"Hay {num_deptos_5_habitaciones:.2f} departamentos con 5 habitaciones."

    elif 'precio promedio de un departamento en renta'in pregunta:
        return f"El precio promedio de un departamento en renta es de {precio_promedio_departamento_renta:.2f}."
    elif 'precio promedio de un departamento en venta'in pregunta:
        return f"El precio promedio de un departamento en venta es de {precio_promedio_departamento_venta:.2f}."

    elif 'precio promedio de un departamento' in pregunta:
        return f"El precio promedio de un departamento es {precio_promedio_departamento:.2f}."


    # alberca
    elif 'propiedades tienen piscina' in pregunta or 'propiedades tienen alberca' in pregunta:
        cantidad_con_piscina = df[df['has_pool'] == 1].shape[0]
        casas_con_alberca = df[(df['property_type'] == 'house') & (df['has_pool'] == 1)].shape[0]
        departamentos_con_alberca = df[(df['property_type'] == 'apartment') & (df['has_pool'] == 1)].shape[0]
        return f"Hay {cantidad_con_piscina} propiedades con alberca. Las cuales estan en {casas_con_alberca} casas y {departamentos_con_alberca} departamentos."
    elif 'properties have a pool' in pregunta:
        cantidad_con_piscina = df[df['has_pool'] == 1].shape[0]
        return f"There are {cantidad_con_piscina} properties with a pool."


    # terraza
    elif 'propiedades tienen terraza' in pregunta or 'terrazas hay' in pregunta:
        con_terraza = df[df['has_terrace'] == 1].shape[0]
        casas_con_terraza = df[(df['property_type'] == 'house') & (df['has_terrace'] == 1)].shape[0]
        departamentos_con_terraza = df[(df['property_type'] == 'apartment') & (df['has_terrace'] == 1)].shape[0]
        return f"Hay {con_terraza} propiedades con terraza. Las cuales estan en {casas_con_terraza} casas y {departamentos_con_terraza} departamentos."
    elif 'properties have a terrace' in pregunta:
        con_terraza = df[df['has_terrace'] == 1].shape[0]
        return f"Their are {con_terraza} properties with a terrace."

    # rango precio
    elif 'rango de precios' in pregunta:
        precio_min = df['last_price'].min()
        precio_max = df['last_price'].max()
        return f"Los precios de las propiedades van desde {precio_min} hasta {precio_max}."
    elif 'range of prices' in pregunta:
        precio_min = df['last_price'].min()
        precio_max = df['last_price'].max()
        return f"The property price range from {precio_min} to {precio_max}."

    elif 'superficie promedio de los departamentos' in pregunta:
        superficie_promedio = df[df['property_type'] == 'apartment']['surface_total'].mean()
        return f"La superficie promedio de los departamentos es de {superficie_promedio:.2f} metros cuadrados."
    elif 'superficie promedio de las casas' in pregunta:
        superficie_promedio = df[df['property_type'] == 'house']['surface_total'].mean()
        return f"La superficie promedio de los departamentos es de {superficie_promedio:.2f} metros cuadrados."

    # # Ba침os
    elif 'promedio de ba침os que hay en una casa' in pregunta:
        return f"En una casa hay un promedio de {promedio_banos_casa} ba침os."
    elif 'promedio de ba침os que hay en un departamento' in pregunta:
        return f"En un departamento hay un promedio de {promedio_banos_departamento} ba침os."
    # elif 'XYZ' in pregunta:
    #     return f"Prueba."

    else:
        return "Lo siento, no puedo responder a esa pregunta. Por favor intenta formularla de otra manera"

"""## Implementacion del chatbot"""

def formatear_pregunta(pregunta):
    # Tokeniza la pregunta para el modelo
    inputs = tokenizer(pregunta, return_tensors='pt')
    return inputs

def chatbot(pregunta):
    # Preprocesar la pregunta
    inputs = formatear_pregunta(pregunta)

    # Procesar la pregunta con el modelo
    output = model(**inputs)
    # La respuesta del modelo se utiliza para entender mejor la intenci칩n de la pregunta.

    # Consulta al dataset (utilizando una funci칩n simplificada aqu칤)
    respuesta = consulta_dataset(pregunta)

    return respuesta

"""# 4) **Probar el chatbot**

***Para probar el chatbot puedes escribir tu pregunta en la celada de abajo o crear una lista de preguntas como se ve 2 celdas abajo.***
"""

# Escribe tu pregunta dentro de las comillas
pregunta = "cual es el precio promedio de una casa en renta?"

# No modificar abajo
respuesta = chatbot(pregunta)

print(f"Pregunta: {pregunta}")
print(f"Respuesta: {respuesta}\n")

# Ejemplo de preguntas
preguntas_para_probar = [
    "쮺u치l es el precio promedio de los departamentos?",
    "쮺u치ntas propiedades tienen piscina?",
    "쮺u치ntas propiedades tienen terraza?",
    "쮺u치l es el rango de precios de las propiedades?",
    "Cuantas casas hay?",
    "Cuantos departamentos hay?"
]

# No modificar abajo

# Probar el chatbot con cada pregunta
for pregunta in preguntas_para_probar:
    respuesta = chatbot(pregunta)
    print(f"Pregunta: {pregunta}")
    print(f"Respuesta: {respuesta}\n")

"""---



# A) Prueba usando BERT

Dado a que usando if/else no es la manera mas efficiente de hacer un chatbot quer칤a probar usando un modelo preentrenado y darle el contexto de los datos.
"""

# Cargando el tokenizador y el modelo BERT
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForQuestionAnswering.from_pretrained('bert-base-uncased')

# Verificando si est치 disponible una GPU y moviendo el modelo a GPU si es posible
if torch.cuda.is_available():
    model = model.cuda()

"""## Contexto"""

# Creando contextos para todas las filas del DataFrame
contextos_completos = []

for _, row in df.iterrows():
    context = f"La propiedad con ID {row['id']} es un {row['property_type']} listado como {row['listing_type']}. \
Tiene un precio de {row['last_price']} y una superficie total de {row['surface_total']} metros cuadrados. \
El precio por metro cuadrado es de {row['price_sqm']}. Tiene {row['num_bedrooms']} habitaciones y {row['num_bathrooms']} ba침os."
    contextos_completos.append(context)

# Mostrando el n칰mero total de contextos creados
# len(contextos_completos)

contexto_general = f"En este dataset, hay un total de {num_casas} casas y {num_depas} departamentos. \
De estas propiedades, {total_renta} est치n listadas para renta y {total_venta} est치n listadas para venta. \
Adem치s, {total_con_alberca} propiedades cuentan con alberca y {total_con_terraza} tienen terraza."

"""## Funcion para preguntas"""

def answer_question(question, context):
    # Tokenizar la pregunta y el contexto, este paso es necesario para que BERT pueda procesarlos
    inputs = tokenizer.encode_plus(question, context, add_special_tokens=True, return_tensors="pt")

    # Mover los tensores a GPU si est치 disponible
    if torch.cuda.is_available():
        inputs = {k: v.cuda() for k, v in inputs.items()}

    # Obtener la respuesta del modelo
    answer_start_scores, answer_end_scores = model(**inputs, return_dict=False)

    # Encontrar los tokens de inicio y fin de la respuesta
    answer_start = torch.argmax(answer_start_scores)
    answer_end = torch.argmax(answer_end_scores) + 1

    # Convertir los tokens de respuesta a texto
    answer = tokenizer.convert_tokens_to_string(tokenizer.convert_ids_to_tokens(inputs["input_ids"][0][answer_start:answer_end]))

    return answer

"""Probar funcion"""

# Ejemplo de pregunta y contexto
pregunta = "쮺u치ntas habitaciones tiene la propiedad?"
contexto = contextos_completos[5]

# Obtener la respuesta de BERT
respuesta = answer_question(pregunta, contexto)
print(respuesta)

pregunta = "쮺uantas casas hay?"
# contexto = contextos_completos
respuesta = answer_question(pregunta, contexto_general)
respuesta

"""Por alguna razon no he logrado que me regrese una respuesta, esto puede deberse a un par de cosas:

- Longitud del Contexto: BERT tiene un l칤mite en la cantidad de tokens que puede procesar en una sola entrada (generalmente alrededor de 512 tokens).

- Formulaci칩n de la Pregunta o del Contexto: BERT puede no entender la pregunta o puede que el contexto que le di no contenga la informaci칩n necesaria de una forma clara.

- Limitaciones del Modelo: Aunque BERT es muy potente, tiene sus limitaciones. No siempre puede inferir respuestas si la pregunta requiere un entendimiento profundo del contexto o si se necesita realizar un c치lculo num칠rico basado en datos.

- Problemas T칠cnicos: Podr칤a haber un problema con la forma en que se est치 ejecutando el modelo o procesando la entrada. Aseg칰rate de que no hay errores en el c칩digo y que las entradas se est치n pasando correctamente al modelo.

---



---



# Exportar Notebook
"""

!pip install nbconvert

!jupyter nbconvert --to html PruebaDD360_1.ipynb

